"""
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
MODULE PURPOSE:
    Inital symetric handshake and identity authentication using globably used (all clients in p2p network use) pre-agreed key
    building of an asymetric agreement between hosts for efficent communication such that other clients cannot snoop in communication between two other endpoints
    asymetric encoding / decoding of voip and text buffer data for prior to and post transmission respectively
    digital signature production and verification to validate source of packets / tampering
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
MODULE NOTES:
    Creating a encryption algorithm / solution from scratch is incredibly, INCREDIBLEY difficult to get right, and even a single failure or misunderstanding when implementing an
    aspect of your solution can result in a catastrophy, as a non specialised developer I opted to specifically use pynacl here mostly because I trust the makers of it
    and I also trust the creator of the original nacl library. the solution bellow may seem incredibly simple, but there is a large amount of steps hidden away by PyNacl
    I reccomend reading the cryptography section of my literature review for a brief overview, then a thorough reading of pynacl's doccumentation from top to bottom.

    Because we are not using PKI, web of trust or any other third party method

    "The ciphertexts generated by Secretbox include a 16 byte authenticator which is checked as part of the decryption. An invalid authenticator will cause the decrypt function
    to raise an exception. The authenticator is not a signature. Once you’ve decrypted the message you’ve demonstrated the ability to create arbitrary valid message, so messages
    you send are repudiable. For non-repudiable messages, sign them after encryption."

    TODO: find a method to transmute inital user supplied password into a 32 byte key for symetric encryption
    TODO: add comments
    TODO: add exceptions
    TODO: decide whether passwords should be stored or whether the user should remember them
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
MODULE TEST CODE:
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
DISSERTATION NOTES:
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
"""
import nacl.utils
import nacl.secret
from nacl.public import PrivateKey, Box
from nacl.signing import SigningKey, VerifyKey

class Symetric:  # Symetric encryption (Xsalsa20) and MAC authentication (Poly1305) to encode / decode data. created globally and used initally for all sockets
    def __init__(self, password):
        self.key = password  # Key MUST be 32 Bytes long
        self.symetric_box = nacl.secret.SecretBox(self.key)

    def encrypt(self, data):
        return self.symetric_box.encrypt(data)

    def decrypt(self, data):
        return self.symetric_box.decrypt(data)



class Asymetric: # Asymetric encryption (Curve25519) and  digital signatures (ED25519) to encode / decode data. created individually per socket session
    def __init__(self):
        self.private_decryption_key = PrivateKey.generate()
        self.public_encryption_key = self.private_decryption_key.public_key
        self.neighbor_public_key = None  #This variable
        self.asymetric_box = None

        self.private_signing_key = SigningKey.generate()
        self.public_verify_key = self.private_signing_key.verify_key
        self.public_verify_key_bytes = self.public_verify_key.encode(self.public_verify_key)
        self.neighbor_verify_key = None


    def asymetric_setup(self, npk, nvk):
        self.neighbor_public_key = npk
        self.neighbor_verify_key = VerifyKey(nvk)
        self.asymetric_box = Box(self.private_decryption_key, self.neighbor_public_key)


    def encrypt(self, data):
        return self.asymetric_box.encrypt(data)

    def decrypt(self, data):
        return self.asymetric_box.decrypt(data)

    def sign(self, data):
        return self.private_signing_key.sign(data)

    def verify(self, data):
        return self.neighbor_verify_key.verify(data)



test = Symetric(nacl.utils.random(32))

