"""
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
MODULE PURPOSE:
    Inital symetric handshake and identity authentication using globably used pre-agreed key (utilised by all clients in p2p network)
    building of an asymetric agreement between hosts for efficent communication such that other clients cannot snoop in communication between two other endpoints.
    asymetric encoding / decoding of voip and text buffer data prior to and post transmission respectively
    digital signature production and verification to validate source of packets / tampering
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
MODULE NOTES:
    Creating a encryption algorithm / solution from scratch is incredibly, INCREDIBLEY difficult to get right, and even a single failure or misunderstanding when implementing an
    aspect of your solution can result in a catastrophy, as a non specialised developer I opted to specifically use pynacl here mostly because I trust the makers of it
    and I also trust the creator of the original nacl library. the solution bellow may seem incredibly simple, but there is a large amount of steps hidden away by PyNacl
    I reccomend reading the cryptography section of my literature review for a brief overview, then a thorough reading of pynacl's doccumentation from top to bottom.

    Because we are not using PKI, web of trust or any other third party method, proof of identity and the security of this method is based on the user password  and five factors:
     - one, the neighbor has the shared, preagreed password and it is sufficently complex to inhibit guessing methods.
     - two, the password isn't compromised and is never shared publicly or stored digitally by the program for future use.
     - three, the client attempts connection to a known good inital client, or client address that they trust minimizing the risk of a bad actor who knows the password or who
              will supply its neighbors with a inital client list that contains bad actors.
     - four, symetric encryption is ONLY used to share enough information to make an asymetric agreement, no voip or text data is symetrically encrypted.
     - five, asymetric encryption provides security for and again'st every other member of the p2p network who knows the password.
     obviously the major flaw of this method is the password itself, as the scale of the p2p network grows, the knowledge, visability and thus security of a given password
     becomes more and more degraded.

    "The ciphertexts generated by Secretbox (symetric encryption) include a 16 byte authenticator which is checked as part of the decryption. An invalid authenticator will
    cause the decrypt function to raise an exception. The authenticator is not a signature. Once you’ve decrypted the message you’ve demonstrated the ability to create
    arbitrary valid message, so messages you send are repudiable. For non-repudiable messages, sign them after encryption." - PyNacl documentation

    TODO: find a method to transmute inital user supplied password into a 32 byte key for symetric encryption
    TODO: add comments
    TODO: add exceptions
    TODO: decide whether passwords should be stored or whether the user should remember them
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
MODULE TEST CODE:

    #SYMETRIC
    test = Symetric(nacl.utils.random(32)) #performed by both clients
    text = b"lorum ipsum"
    text = test.encrypt(text)  # Sender side
    print (text)
    text = test.decrypt(text)  # reciever side
    print (text)

    #ASYMETRIC (This example doesnt account for symetric transfer of npk and nvkb and is for illustration purposes)
    test2 = Asymetric()  # one side of the exchange
    test3 = Asymetric()  # second side of the exchange
    test2.setup(test3.public_encryption_key, test3.public_verify_key_bytes)
    test3.setup(test2.public_encryption_key, test2.public_verify_key_bytes)
    text = test2.encrypt(b"test")
    print(text)
    text = test3.decrypt(text)
    print(text)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
DISSERTATION NOTES:
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
"""
import nacl.utils
import nacl.secret
from nacl.public import PrivateKey, Box
from nacl.signing import SigningKey, VerifyKey


class Symetric:  # Symetric encryption (Xsalsa20) and MAC authentication (Poly1305) to encode / decode data. created globally and used initally for all sockets
    def __init__(self, password):
        if len(password) < 10:  # This is arbitrary, it would be better practice to use a perfectly random 32 byte key but this is hard to remember
            raise.ValueError
        else:
            while len(self.key.encode('utf-8')) < 32:
                self.key = password  # Key MUST be 32 Bytes long
        self.symetric_box = nacl.secret.SecretBox(self.key)  # create a box to encrypt and decrypt with


    def encrypt(self, data):  # symetrically encrypt data
        return self.symetric_box.encrypt(data)

    def decrypt(self, data):  # symetrically decrypt data
        return self.symetric_box.decrypt(data)


class Asymetric:  # Asymetric encryption (Curve25519) and  digital signatures (ED25519) to encode / decode data. created individually per socket session
    def __init__(self):
        self.private_decryption_key = PrivateKey.generate()
        self.public_encryption_key = self.private_decryption_key.public_key
        self.neighbor_public_key = None
        self.asymetric_box = None

        self.private_signing_key = SigningKey.generate()
        self.public_verify_key = self.private_signing_key.verify_key
        self.public_verify_key_bytes = self.public_verify_key.encode()
        self.neighbor_verify_key = None

    def setup(self, npk, nvkb):  # this function initalises the Asymetric instance for actual usage once the neighbor has sent their npk and nvk with symetric encryption
        self.neighbor_public_key = npk
        self.neighbor_verify_key = VerifyKey(nvkb)
        self.asymetric_box = Box(self.private_decryption_key, self.neighbor_public_key)

    def encrypt(self, data):
        return self.asymetric_box.encrypt(self.private_signing_key.sign(data))


    def decrypt(self, data):
        return self.neighbor_verify_key.verify(self.asymetric_box.decrypt(data))




test1 = Symetric("test")
text = test1.encrypt(b"test")
text = test1.decrypt(text)
print(text)

test = Symetric("password")